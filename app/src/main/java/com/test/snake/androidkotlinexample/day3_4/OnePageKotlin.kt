package com.test.snake.androidkotlinexample.day3_4

import java.util.*

/**
 * Created by snake on 17. 11. 5.
 */

// 울트라초보를 위한
// 빠르게 참고할 수 있는
// 필수코딩..
// 1개의 소스로 요약

//--------------------------------------------------------------------------------------------------
// 1. Kotlin 최초의 소스
// 아무것도 안하는 메인함수
// args는 입력되는 매개변수
//--------------------------------------------------------------------------------------------------

// Android Studio에서는 아래 메인함수를 실행하고자 한다면
// 많은 부분을 수정해야 한다.
fun main (args : Array<String>){

}

//--------------------------------------------------------------------------------------------------
// 2. 변수는 ReadOnly와 읽고쓰기가 가능한 경우가 있음.
//--------------------------------------------------------------------------------------------------
fun 변수설명하는예제(){

    // 1. 변수의 타입을 미리 정함
    // 아래는 초기화하지 않아도 됨.
    var num : Int;
    num = 1;

    // 2. 변수의 타입을 정하지 않음
    // 아래는 초기화 반드시 해야함.

    // var number; <-- 에러임
    var number = 2;

    // 아래도 에러발생
    // number = "";
    // 즉, 선언과 함께 초기화를 하면 알아서 타입을 정하는 기능정도인 듯.

    // val은 const와 같은 읽기전용값임.
    val num2 = 1;
    val name : String;
    name = "";

    // 에러임. 이미 할당한 값을 재할당 못함.
    //name = "저장";
}

//--------------------------------------------------------------------------------------------------
// 3. 코틀린에서는 변수에 값이 없는 데, 비교하거나 계산하는 것을 원천봉쇄하겠다는 의지가 강하다.
//--------------------------------------------------------------------------------------------------
fun 변수와NULL예제(){
    // null 채크를 좀 심하게 하는 언어같음.
    // null을 넣는다고 다 들어가지 않음.
    // 변수기본이 null을 대입할 수 없음.
    // 아무래도 null처리로 인한 버그가 많으므로
    // kotlin이라는 언어는 그것을 강하게 제어하겠다는 의지로 보임.

    var number : Int? = 10;
    number = null;

    // 사용법: data형 끝에 ?를 붙인다.
}

//--------------------------------------------------------------------------------------------------
// 4. 코틀린에서 숫자형과 데이터 타입
//--------------------------------------------------------------------------------------------------
fun 숫자형과데이터타입예제() {
    // 숫자형 DataType 크기 순으로 선언
    // 정확한 크기를 알 필요는 거의 없음.
    // 대부분 왠만한 수는 Int로 해결되니까..
    var 더블  : Double = 10.1111;
    var 플롯  : Float  = 10.1f;
    var 롱    : Long   = 10;
    var 인티저: Int    = 10;
    var 쇼트  : Short  = 10;
    var 바이트: Byte   = 10;

    // 출력해보기
    println (더블);
    println (플롯);
    println (인티저 );

    // 크기변환 후, 대입 : 캐스팅
    // to대입할크기() 메소드를 사용한다.
    더블   = 인티저.toDouble();
    인티저 = 더블.toInt();

}

//--------------------------------------------------------------------------------------------------
// 5. 변수의 범위
// 개발자에게는 너무나 당연한 내용이지만,
// 처음 프로그래밍을 배우는 사람들은 반드시 실수하는 것.
// 변수를 인식하는 범위: Scope
//--------------------------------------------------------------------------------------------------

// {} 밖에 있으므로 {}안에서는 알 수 있다.
var gName : String = "전역처리"

fun 변수범위테스트예제(){
    println(gName);

    // {}안의 변수는 {} 밖에서 접근못함.
    if(true){
        var lName = "지역처리";
        println(lName);
        println(gName);
    }

    // 모르는 변수라 에러발생.
    //println(lName);
}


//--------------------------------------------------------------------------------------------------
// 6. 문자열
// 프로그래밍에서 문자열 만들기는 언제나 행하는 과정 중에 하나이다.
//--------------------------------------------------------------------------------------------------
fun 문자열처리함수예제(){

    var sName = "문자열 테스트입니다. ";

    // 1.문자열을 추가하는 것은 + 연산자로 가능함 <- Java와 동일
    println (sName + " : 문자열 붙이기");

    // 2. """ 이 안에 줄넘김 문자열이 들어갈 수 있다. """
    // Python에 이런 기능이 있다.
    var s줄넘김문자열 = """
    어떻게 출력 될지..
모르겠지만
    마치 HTML의 <pre>와 비슷할....
            듯
    """
    println(s줄넘김문자열);

    // 3. 문자열 내의 포멧팅 방법
    // linux의 bash와 비슷함.

    var s포멧문자열 = "sName의 값을 가져오는 것: $sName";
    println(s포멧문자열);

    // 4. linux bash와 비슷하니
    // ${}안에
    // 함수호출이나 수식처리도 가능함.
    var s포멧문자열2 = "sName의 값을 가져오는 것: ${sName + "움하하하" + Date()}"; // Java class도 가져욜 수 있음.
    println(s포멧문자열2);

}

//--------------------------------------------------------------------------------------------------
// 7. 함수사용하기
// 프로그래밍은 함수를 만드는 과정이다.
//--------------------------------------------------------------------------------------------------
fun 함수사용하기예제(){
    // kotlin에서 함수는 pascal 문법과 유사하다(그렇다지만 프로시져와 함수의 구분은 없다.).
    // fun 함수명(변수명 : 데이터크기, ...) : 리턴값 { return; }
    // 의 형태로 되어있다.
    매개변수없는함수();
    매개변수2개있는함수(3, " 숫자입니다");
    println ( 리턴값이있는함수("3을 넘기니") );
    println( 리턴값있는_한줄함수(3, 10)) ;
}

fun 리턴값이있는함수(s: String): Any? {
    return s + "-를 입력받았습니다.";
}

fun 매개변수2개있는함수(i: Int, s: String) {
    println (i.toString() + s);
}

fun 리턴값있는_한줄함수(i: Int, i1: Int) = i * i1;

fun 매개변수없는함수() {
    println ("매개변수 없어요");
}


//--------------------------------------------------------------------------------------------------
// 8. 함수사용하기
// 프로그래밍은 함수를 만드는 과정이다.
//--------------------------------------------------------------------------------------------------
fun Any설명예제(){
    // any는 C에서 void*와 같은 역할을 하는 듯.
    // 어떠한 데이터 형의 변수이던간에 담을 수 있는 크기.
    var 뭐던 : Any;

    뭐던 = 1;
    뭐던 = "문자열";
    뭐던 = 111.01010;
    뭐던 = 10.00f;

    // is와 !(not) 연산자로 어떤 데이터 형인지 채크가 가능함.
    if(뭐던 !is String) {

        if (뭐던 is Float) {
            println("float입니다");
        }

    }

}


//--------------------------------------------------------------------------------------------------
// 9. 제어문
// 제어문이 없는 프로그래밍은 존재한 적이 없다.
//--------------------------------------------------------------------------------------------------
fun 제어문예제(){
    비교문예제();
    반복문예제();
    case문예제();
}

fun case문예제() {
    //var obj : Any?  = "aaaa";
    var obj : Any?  = 10.00f;
    //var obj : Any?  = 8;

    when(obj){
        "aaaa"      -> {println ("문자:" + obj )}
        is Float    -> {println ("숫자:" +  obj)}
        in (0 .. 9) -> {println ("0-10까지 숫자")}
        else        -> {println ("???")}
    }
}

fun 반복문예제() {
    // 반복문 for: in과 (시작..끝)으로 반복가능. ()는 생략가능
    for (i in (0..10)  ){
        println ("i -> " + i );
    }

    // 반복문 while: while(조건){}
    var i : Int = 0;
    while(i < 10){ i++; println ("$i 입니다."); }
}

fun 비교문예제() {
    // 비교문
    //var a : Any?  = "aaaa";
    //var a : Any?  = 10.00f;
    //var a : Any?  = 8;
    var a : Any?  = null;

    if (a == "aaaa"){              // ==를 이용한 값비교
        println ("문자:" + a );

    } else if( a is Float )  {     // is를 이용한 형비교
        println ("숫자:" +  a);

    } else if (a in (0..9) ){      // in을 이용한 범위비교
        println ("0-10까지 숫자");

    } else if (a == null ){
        println ("null!");
    }
}

//--------------------------------------------------------------------------------------------------
// 10. 컬렉션
// 1개 이상의 데이터를 뭉탱이로 관리하고자 한다면...
//--------------------------------------------------------------------------------------------------
fun 컬렉션예제(){
    // 읽기전용 -  list. 데이터형을 마구 섞어도 된다.
    val 리스트 = listOf(1, "헉", 3.00f, true);
    for (i in 0 .. 리스트.size - 1){
        println ( 리스트.get(i).toString() ) ;
    }

    // 수정가능 - List. 데이터형을 미리 정해야 하는 듯.
    println("__________")
    var 수정가능리스트 = mutableListOf<String>();

    // add 메소드로 추가
    수정가능리스트.add("나는야");
    수정가능리스트.add("우주의");
    수정가능리스트.add("판타지");
    수정가능리스트.add("이박사");

    for(s in 수정가능리스트){
        println(s)
    }

    println("__________")

    // remove 메소드로 삭제
    수정가능리스트.removeAt(0);
    for(s in 수정가능리스트){
        println(s)
    }

    println("__________")

    // Map: java보다 불편한 듯.
    var 맵 = hashMapOf("고양이" to 1, "강아지" to 2);
    println(맵["고양이"]);

}


//--------------------------------------------------------------------------------------------------
// 11. 예외처리
// 특정환경에서 발생하는 에러가 예상된다면 반드시 try catch 문으로 둘러쌓아야 한다.
// 선택이 아니라 필수이다. 이렇게안하면 컴파일(번역)이 안된다.
//--------------------------------------------------------------------------------------------------
fun 예외처리예제(){
    // java와 흡사하다.
    try{
        13 / 0;
    } catch(e: Exception){
        println(e);
    } finally {
        println("마지막 수행.")
    }
}


//--------------------------------------------------------------------------------------------------
// 12. 객체지향
// 절대로 단시간에 이해할 수 없음.
// 단지 객체지향의 기술이 있기에
// 누군가 만든 수십만 라인의 코드를 단 한 줄로
// 가져다 처리가 가능하다는 것만
// 인지하고 있으면 됨.
//--------------------------------------------------------------------------------------------------
fun 클래스예제(){
    var 오브젝트1 = 클래스1();
    var 오브젝트2 = 클래스1("파라메터 받음.");

    var 오브젝트3 = 선조클래스();
    println( 오브젝트3.getMyName() );

    var 오브젝트4 = 상속클래스();
    println( 오브젝트4.getMyName() );
}

// class 이름(변수명: 데이터형, ..){} 으로 생성자를 만들어쓰기도 한다.
class 클래스1{
    var name : String = "";

    // 기본 생성자
    constructor(){
        println("기본생성자");
    }
    // 오버로딩된 생성자
    constructor(name : String ){
        this.name = name;
        println("$name 을 입력받은 생성자");
    }
}

// kotlin에서는 기본적으로 상속이 거부되어 있다. 그래서 선조클래스를 open으로 지정해야 한다.
open class 선조클래스 {
    var name : String = this.toString();
    fun getMyName() : String = name;
}

//  상속받을 떄는 선조클래스를 "class 이름 : 선조클래스명(생성자인자){}" 형식으로 해야 한다.
class 상속클래스 : 선조클래스(){

}

//--------------------------------------------------------------------------------------------------
// 13. 객체지향 - 오버라이딩, 오버로딩
// 오버로딩: 남이 만들어놓은 것을 내가 그 함수만 다시 고치고 싶을 때....
// 오버로딩: 함수명은 하나인데 파라메터는 여러개 쓰고싶을 떄...
//--------------------------------------------------------------------------------------------------
fun 오버라이딩예제(){
    var 오브젝트1 = baseClass();
    오브젝트1.func1();

    var 오브젝트2 = childClass();
    오브젝트2.func1();
    오브젝트2.func2();
    오브젝트2.func2("문자열 파라메터");
    오브젝트2.func2("문자열 파라메터", 100);
}

open class baseClass{
    // 상속받은 클래스에서 오버라이드하려면 선조클래스에서 open으로 정의.
    open var name = "base";
    open fun func1() = println(this.toString());

    // 외부사용금지 .찍고 메소드 사용못함.
    private fun onlyMyFunc() = println("클래스내부에서만 사용");
    constructor(){
        onlyMyFunc();
    }
}

class childClass : baseClass(){
    override var name = "";
    override fun func1() = println(this.toString() + " 재정의함.");
    fun func2() = println("func2");

    // overloding
    fun func2(s : String ) = println("func2:$s ");
    fun func2(s : String, num : Int ) = println("func2: $s, $num  ");

}

//--------------------------------------------------------------------------------------------------
// 14. 람다식
// 식별자 없이 실행 가능한 함수 표현식. 가독성을 위해 코드를 줄이는 것.
// 정의 1 : 함수형 변수는
//
// { 변수정의 -> 함수구현 }
//
// 정의 2: 함수형 변수의 크기는

// 이름 : (변수정의)->리턴형
//--------------------------------------------------------------------------------------------------
fun 람다식예제(){
    // 가장 심플한 람다식 표현
    var 그냥함수변수 = {a: Int, b: Int -> a + b};

    // 그냥함수변수는 그냥함수 : (Int, Int) -> Int 형으로 표현가능하다.
    // C/C++ 에서 함수형변수 정의하는 것과 유사하다.
    함수가인자라네( 그냥함수변수 );
}

// kotlin에서도 generic이 사용된다.
fun 함수가인자라네( func : (Int, Int) -> Int  ){
    func(10, 10).let { 결과값 ->  println("결과값은 $결과값 입니다") };
}